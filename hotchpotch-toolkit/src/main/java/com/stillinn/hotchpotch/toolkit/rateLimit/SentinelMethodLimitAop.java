package com.stillinn.hotchpotch.toolkit.rateLimit;import com.alibaba.csp.sentinel.Entry;import com.alibaba.csp.sentinel.SphU;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.alibaba.csp.sentinel.slots.block.RuleConstant;import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;import org.apache.commons.lang3.StringUtils;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * @author stillinn * Created on 2023-07-02 */@Aspect@Componentpublic class SentinelMethodLimitAop {    private static final Logger LOGGER = LoggerFactory.getLogger(SentinelMethodLimitAop.class);//    @Pointcut("execution(* com.ssm.boot.admin..*(..))")    @Pointcut(value = "@annotation(com.stillinn.hotchpotch.toolkit.rateLimit.SentinelLimitAnnotation)")    public void rateLimit() {    }    @Around("rateLimit()")    public Object limit(ProceedingJoinPoint joinPoint) {        // 获取调用方法        Method method = getCurrentMethod(joinPoint);        if (method == null) {            return null;        }        // 获取resourceName        String resourceName = method.getAnnotation(SentinelLimitAnnotation.class).resourceName();        int limitCount = method.getAnnotation(SentinelLimitAnnotation.class).limitCount();        if (StringUtils.isEmpty(resourceName)) {            throw new RuntimeException("resourceName is Empty");        }        initFlowRule(resourceName, limitCount);        Entry entry = null;        Object result = null;        try {            entry = SphU.entry(resourceName);            try {                // 执行业务逻辑                result = joinPoint.proceed();            } catch (Throwable e) {                LOGGER.error("run method fail, method: {}", method.getName(), e);            }        } catch (BlockException e) {            /*流控逻辑处理 - 开始*/            LOGGER.warn("blocked");            result = "blocked";            /*流控逻辑处理 - 结束*/        } finally {            if (entry != null) {                entry.exit();            }        }        return result;    }    // 设置限流规则    private void initFlowRule(String resourceName, int limitCount) {        List<FlowRule> rules = new ArrayList<>();        // todo: resourceName 重复设置问题        FlowRule rule = new FlowRule();        rule.setResource(resourceName);        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);        rule.setCount(limitCount);        rules.add(rule);        FlowRuleManager.loadRules(rules);    }    private Method getCurrentMethod(JoinPoint joinPoint) {        Method[] methods = joinPoint.getTarget().getClass().getMethods();        Method target = null;        for (Method method : methods) {            if (method.getName().equals(joinPoint.getSignature().getName())) {                target = method;            }        }        return target;    }}